
// ДЗ  Задача 7. 
/* 1. Реализовать структуру данных граф и два способа обхода графа:
 - в глубину (DFS)
 - в ширину (BFS)  
На вход будет подан массив ребер графа [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]
В результате должна быть структура, принимающая массив ребер и имеющая две функции, при вызове которых
будет выполнять обход вершин. Посещаемые вершины должны выводиться на экран.
*/
 

"use strict";

// 1. объявление объектов *****************************************************************************************
// Спецификация - обозначение узлов по номерам

// описание графа. В нем - узлы и методы заполнения и обхода 
class Graf {
    constructor() {
        this.nodes = [];
    }
    
    // Методы графа
    //-------- метод - добавление одного узла
    addEdges(value, lines) {
      this.nodes.push({
        value: value,
        visited: false,
        lines: lines.slice(0) // копируем массив по значениям элементов
    });
    }
    
        //-------maxNodeNum - Определение номера последней вершины по списку ребер edges 
        maxNodeNum (edges) {
        let max = 0;
        let i = 0;

        for (i = 0; i < edges.length; i++) {
            if (max < Math.max.apply(null, edges[i])) max = Math.max.apply(null, edges[i]);
        }
        return max;
        }
        // end maxNodeNum

    //-------fillGraf метод - добавление всех узлов графа со списком смежных узлов из входного массива ребер
    fillGraf(edges) {
      let i = 0;
      let j = 0;
      let linesTmp = [];

      let n = this.maxNodeNum(edges); //номер последнего узла


      for (i = 0; i <= n; i++) {  // в цикле до последнего узла формируем узлы из из входного массива ребер
  
      linesTmp.length = 0;
      for (j = 0; j < edges.length; j++) {  // цикл по числу элементов входного массива дуг
      // заносим номера смежных узлов для текущего i-го узла, перебирая ребра из входного массива, через промежуточный массив linesTmp 
      // и функцию addEdges - добавления узла:
      if (edges [j][0] == i) {
        linesTmp.push(edges [j][1]);
      }
      if (edges [j][1] == i) {
        linesTmp.push(edges [j][0]);
      }
      } 
  
      this.addEdges(i, linesTmp); // добавляем узел в структуру графа
      }
    }
    //fillGraf end
    
    // ----- resetNodes - восстановление состояния графа
    resetNodes () {
    let i = 0;
    let n = this.maxNodeNum(edges); //номер последнего узла
    for (i = 0; i <= n; i++) {      
    graf.nodes[i].visited = false;
    }
    }
    // end resetNodes

    //------- dfs - метод обхода в глубину:
    /*
    dfs - Алгоритм поиска в глубину
    Шаг 1. Всем вершинам графа присваивается значение не посещенная. Выбирается первая вершина и помечается как посещенная.
    Шаг 2. Для последней помеченной как посещенная вершины выбирается смежная вершина, являющаяся первой помеченной как не посещенная, 
    и ей присваивается значение посещенная.Если таких вершин нет, то берется предыдущая помеченная вершина.
    Шаг 3. Повторить шаг 2 до тех пор, пока все вершины не будут помечены как посещенные

    */
      dfs(k, prev = []) {
      let i = 0;
      let j = 0;
      
      graf.nodes[k].visited = true; //  узел на входе помечаем как посещенный
      console.log(k);
      
      if (k != prev[prev.length - 1]) prev.push(k); // сохраняем маршрут в стеке, т.е. номер текущего узла как предыдущего 
      
      for (i=0; i < graf.nodes[k].lines.length; i++) { //перебираются все смежные узлы для текущего:
        j = graf.nodes[k].lines[i]; 
        if (graf.nodes[j].visited == false) {
          this.dfs(j, prev); // переход к первому найденному непосещенному узлу вглубь
        } 
        
      }
      // возврат на предыдущий уровень, т.к. перебрали список смежности, но непосещенных узлов не нашли
      prev.pop(); // убираем из стека текущий узел, на его выходе становится - предыдущий узел
      if (prev.length == 0) return;  // выход когда стек с маршрутом опустел при обратном движении 
      k = prev[prev.length-1]; // берем из конца массива предыдущий узел на маршруте, т.е. из стека, чтобы вернуться
      this.dfs(k, prev); // рекурсивно вызываем функцию обхода
    } 
    // end dfs  

    /*------- bfs - Алгоритм поиска в ширину
    Шаг 1. Всем узлам графа присваивается значение не посещенный.
    Шаг 2. Выбирается входной узел из очереди и помечается как посещенный (??? и заносится в очередь).
           Посещение: перебираются все смежные узлы: если смеж.узел не помечен как посещенный, помечается и его номер заносится в очередь для посещения.
           После завершения перебора входной-текущий узел удаляется из очереди. Очередь сдвигается и следующий за ним становится первым в очереди.
    Шаг 3. Повторяется шаг 2 до тех пор, пока очередь не пуста
    */ 
    bfs(k, next = [])  {
      let i = 0;
      let j = 0;
      if (next.length == 0) next.push(k); //самый первый узел заносится в очередь для посещения.
      graf.nodes[k].visited = true; //  узел на входе помечаем как посещенный
      console.log(k);
            
      for (i=0; i < graf.nodes[k].lines.length; i++) { //перебираются все смежные узлы:
        j = graf.nodes[k].lines[i]; 
        if (graf.nodes[j].visited == false) { //если смеж.узел не помечен как посещенный,   
          graf.nodes[j].visited = true; // то помечается и
          next.push(j); //его номер заносится в очередь (в конец массива)
        } 
        
      }
      // После завершения перебора входной узел удаляется из очереди.
      next.shift(); // обработанный текущий узел выходит из очереди  (из начала массива), 
      if (next.length == 0) return;  // выход из функции или повторяется шаг 2 до тех пор, пока очередь не пуста 
      k = next[0];
      this.bfs(k, next); // рекурсивно вызываем функцию обхода
    } 
    // end bfs  
}
//end Graf

// 2. работа с графом *****************************************************************************************

//let edges = [ [0, 2], [0, 3],  [1, 3], [2, 3], [4, 3], [5, 4], [4, 6]]; //отладка
let edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]; // по условию

let graf = new Graf();
graf.fillGraf(edges);
console.log('обход в глубину');
graf.dfs(0);
graf.resetNodes(); //восстановление состояния графа

console.log('обход в ширину');

graf.bfs(0);

console.log('end');




